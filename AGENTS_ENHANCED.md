# üß† AGENTS.md ‚Äî R√®glement int√©rieur des IA (ENHANCED) ‚Ä¢ M√©ta-r√©flexivit√© & Symbiose

> **Extension du fichier AGENTS.md original**  
> **Objectif** : Transformer le d√©p√¥t en un **√©cosyst√®me intelligent auto-document√©** qui guide les IA d√©veloppeuses vers l'excellence et pr√©vient la d√©g√©n√©rescence du projet √† long terme.

---

## üéØ M√©ta-r√©flexivit√© : L'IA qui se pense elle-m√™me

### Principe fondamental

Les IA d√©veloppeuses ne sont pas de simples ex√©cutantes. Elles sont des **architectes r√©flexives** capables de :

1. **Questionner leurs propres hypoth√®ses** avant de coder
2. **Anticiper les cons√©quences** de leurs d√©cisions sur le long terme
3. **D√©tecter les patterns de d√©g√©n√©rescence** (code dupliqu√©, abstractions fuyantes, couplage fort)
4. **Auto-corriger** leurs erreurs en analysant les √©checs pass√©s
5. **Documenter leur raisonnement** pour les IA futures

### Cycle m√©ta-r√©flexif (obligatoire avant toute contribution)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. LECTURE PROFONDE                                         ‚îÇ
‚îÇ     ‚îú‚îÄ Lire AGENTS.md, README.md, DOCUMENTATION/            ‚îÇ
‚îÇ     ‚îú‚îÄ Calculer hash SHA-256 des fichiers lus               ‚îÇ
‚îÇ     ‚îî‚îÄ Poster Acknowledgement.v1                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  2. QUESTIONNEMENT                                           ‚îÇ
‚îÇ     ‚îú‚îÄ Quelle est la vraie intention derri√®re cette t√¢che ? ‚îÇ
‚îÇ     ‚îú‚îÄ Quels sont les invariants √† pr√©server ?              ‚îÇ
‚îÇ     ‚îú‚îÄ Quelles sont les cons√©quences √† long terme ?         ‚îÇ
‚îÇ     ‚îî‚îÄ Existe-t-il une solution plus simple/√©l√©gante ?      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  3. PLANIFICATION                                            ‚îÇ
‚îÇ     ‚îú‚îÄ R√©diger un plan court (‚â§ 200 mots)                   ‚îÇ
‚îÇ     ‚îú‚îÄ Identifier les risques et les mitigations            ‚îÇ
‚îÇ     ‚îî‚îÄ D√©finir les artefacts √† produire                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  4. VALIDATION PR√âALABLE                                     ‚îÇ
‚îÇ     ‚îú‚îÄ V√©rifier la coh√©rence avec les sch√©mas JSON          ‚îÇ
‚îÇ     ‚îú‚îÄ Simuler mentalement l'impact sur l'architecture      ‚îÇ
‚îÇ     ‚îî‚îÄ Consulter les ADR (Architecture Decision Records)    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  5. IMPL√âMENTATION                                           ‚îÇ
‚îÇ     ‚îú‚îÄ Coder en OOP, g√©n√©rer docs .md auto                  ‚îÇ
‚îÇ     ‚îú‚îÄ Cr√©er les tests et goldens                           ‚îÇ
‚îÇ     ‚îî‚îÄ Mesurer les performances (CPU, latence, m√©moire)     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  6. AUTO-CRITIQUE                                            ‚îÇ
‚îÇ     ‚îú‚îÄ Relire le code comme si c'√©tait celui d'un autre     ‚îÇ
‚îÇ     ‚îú‚îÄ Identifier les faiblesses et les am√©liorer           ‚îÇ
‚îÇ     ‚îî‚îÄ Documenter les d√©cisions non √©videntes               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  7. DOCUMENTATION R√âFLEXIVE                                  ‚îÇ
‚îÇ     ‚îú‚îÄ Expliquer POURQUOI, pas seulement QUOI               ‚îÇ
‚îÇ     ‚îú‚îÄ Anticiper les questions des IA futures               ‚îÇ
‚îÇ     ‚îî‚îÄ Cr√©er des exemples concrets et des contre-exemples   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Questions m√©ta-r√©flexives √† se poser syst√©matiquement

#### Avant de coder

- **Intention** : Quelle est la vraie intention derri√®re cette fonctionnalit√© ?
- **Alternatives** : Existe-t-il une solution plus simple qui r√©sout le m√™me probl√®me ?
- **Invariants** : Quels sont les invariants du syst√®me que je dois pr√©server ?
- **Cons√©quences** : Quelles seront les cons√©quences de cette d√©cision dans 6 mois ? 1 an ?
- **R√©versibilit√©** : Cette d√©cision est-elle facilement r√©versible si elle s'av√®re mauvaise ?

#### Pendant le codage

- **Coh√©rence** : Mon code est-il coh√©rent avec le reste de l'architecture ?
- **Simplicit√©** : Puis-je simplifier sans perdre en expressivit√© ?
- **Testabilit√©** : Mon code est-il facilement testable ?
- **Maintenabilit√©** : Un autre d√©veloppeur (IA ou humain) pourra-t-il comprendre ce code dans 1 an ?

#### Apr√®s le codage

- **Auto-critique** : Si je devais critiquer ce code, quels seraient les points faibles ?
- **Documentation** : Ai-je document√© les d√©cisions non √©videntes ?
- **Tests** : Mes tests couvrent-ils les cas limites et les erreurs ?
- **Performance** : Ai-je mesur√© l'impact sur les performances (CPU, latence, m√©moire) ?

---

## üîÑ Anti-d√©g√©n√©rescence : Pr√©venir la dette technique

### Patterns de d√©g√©n√©rescence √† d√©tecter et √©viter

#### 1. **Code dupliqu√©**

**Sympt√¥me** : M√™me logique r√©p√©t√©e √† plusieurs endroits

**D√©tection** :
```bash
# Rechercher les duplications
grep -r "function calculateMIDIValue" projet/
```

**Rem√®de** : Extraire dans une fonction utilitaire r√©utilisable

**Exemple** :
```javascript
// ‚ùå MAUVAIS : Code dupliqu√©
function convertCutoffToMIDI(value) {
    return Math.floor(value * 127);
}

function convertResonanceToMIDI(value) {
    return Math.floor(value * 127);
}

// ‚úÖ BON : Fonction g√©n√©rique
function convertNormalizedToMIDI(value, curve = "lin") {
    const raw = value * 127;
    
    switch (curve) {
        case "lin": return Math.floor(raw);
        case "exp": return Math.floor(Math.pow(raw / 127, 2) * 127);
        case "log": return Math.floor(Math.sqrt(raw / 127) * 127);
        default: throw new Error(`Unknown curve: ${curve}`);
    }
}
```

#### 2. **Abstractions fuyantes**

**Sympt√¥me** : Les d√©tails d'impl√©mentation fuient √† travers les couches

**D√©tection** : Si le code UI conna√Æt les d√©tails MIDI, c'est une fuite

**Rem√®de** : Encapsuler dans des abstractions claires

**Exemple** :
```javascript
// ‚ùå MAUVAIS : UI conna√Æt les d√©tails MIDI
button.onclick = () => {
    const midiValue = Math.floor(slider.value * 127);
    sendMIDICC(19, midiValue, 1);  // UI conna√Æt CC 19 = cutoff
};

// ‚úÖ BON : Abstraction claire
button.onclick = () => {
    machine.setParameter("cutoff", slider.value);  // UI ne conna√Æt que le nom
};

class Machine {
    setParameter(name, value) {
        const mapping = this.spec.midi.ccMap.find(m => m.name === name);
        if (!mapping) throw new Error(`Unknown parameter: ${name}`);
        
        const midiValue = convertNormalizedToMIDI(value, mapping.curve);
        this.sendCC(mapping.cc, midiValue);
    }
}
```

#### 3. **Couplage fort**

**Sympt√¥me** : Modifier un module n√©cessite de modifier plusieurs autres modules

**D√©tection** : Compter les d√©pendances entre modules

**Rem√®de** : Utiliser l'injection de d√©pendances et les interfaces

**Exemple** :
```javascript
// ‚ùå MAUVAIS : Couplage fort
class Sequencer {
    constructor() {
        this.midiManager = new MIDIManager();  // D√©pendance hard-cod√©e
    }
}

// ‚úÖ BON : Injection de d√©pendances
class Sequencer {
    constructor(midiManager) {
        this.midiManager = midiManager;  // Inject√© de l'ext√©rieur
    }
}

// Utilisation
const midiManager = new MIDIManager();
const sequencer = new Sequencer(midiManager);
```

#### 4. **Manque de tests**

**Sympt√¥me** : Peur de refactoriser car on ne sait pas ce qui va casser

**D√©tection** : Couverture de code < 80%

**Rem√®de** : √âcrire des tests avant de refactoriser

**Exemple** :
```javascript
// Test avant refactoring
describe("convertNormalizedToMIDI", () => {
    test("linear curve", () => {
        expect(convertNormalizedToMIDI(0.0, "lin")).toBe(0);
        expect(convertNormalizedToMIDI(0.5, "lin")).toBe(63);
        expect(convertNormalizedToMIDI(1.0, "lin")).toBe(127);
    });
    
    test("exponential curve", () => {
        expect(convertNormalizedToMIDI(0.0, "exp")).toBe(0);
        expect(convertNormalizedToMIDI(0.5, "exp")).toBeGreaterThan(31);
        expect(convertNormalizedToMIDI(1.0, "exp")).toBe(127);
    });
});
```

#### 5. **Documentation obsol√®te**

**Sympt√¥me** : La documentation ne correspond plus au code

**D√©tection** : Comparer les hash SHA-256 des fichiers document√©s

**Rem√®de** : G√©n√©rer la documentation automatiquement depuis le code

**Exemple** :
```javascript
/**
 * Convertit une valeur normalis√©e (0.0-1.0) en valeur MIDI (0-127).
 * 
 * @param {number} value - Valeur normalis√©e (0.0-1.0)
 * @param {string} curve - Courbe de conversion ("lin", "exp", "log")
 * @returns {number} Valeur MIDI (0-127)
 * 
 * @example
 * convertNormalizedToMIDI(0.5, "lin")  // 63
 * convertNormalizedToMIDI(0.5, "exp")  // 31
 */
function convertNormalizedToMIDI(value, curve = "lin") {
    // ...
}

// G√©n√©rer automatiquement la documentation
// npm run generate-docs
```

### M√©triques de sant√© du projet (√† surveiller)

| M√©trique | Cible | Seuil d'alerte | Action si d√©pass√© |
|----------|-------|----------------|-------------------|
| Couverture de tests | > 80% | < 70% | Ajouter des tests |
| Complexit√© cyclomatique | < 10 | > 15 | Refactoriser |
| Duplication de code | < 5% | > 10% | Extraire fonctions communes |
| D√©pendances circulaires | 0 | > 0 | R√©organiser modules |
| Taille moyenne des fonctions | < 50 lignes | > 100 lignes | D√©couper |
| Nombre de TODOs | D√©croissant | Croissant | Planifier r√©solution |

---

## ü§ù Symbiose IA ‚Üî D√©p√¥t : Le d√©p√¥t comme organisme vivant

### Le d√©p√¥t n'est pas un simple stockage de code

Le d√©p√¥t GitHub est un **organisme vivant** qui :

1. **Communique** avec les IA via la documentation
2. **Guide** les IA via les sch√©mas JSON et les ADR
3. **Valide** les contributions via les tests et les goldens
4. **Apprend** de ses erreurs via les logs SQLite et l'historique Git
5. **√âvolue** de mani√®re coh√©rente gr√¢ce aux conventions strictes

### M√©canismes de symbiose

#### 1. **Documentation auto-d√©couvrable**

Le d√©p√¥t doit √™tre **auto-document√©** : une IA qui arrive doit pouvoir comprendre le projet en lisant uniquement les fichiers du d√©p√¥t.

**Structure de d√©couverte** :
```
README.md                    ‚Üê Point d'entr√©e : vision, quick start, architecture
AGENTS.md                    ‚Üê R√®gles pour les IA d√©veloppeuses
DOCUMENTATION/
‚îú‚îÄ‚îÄ APP/
‚îÇ   ‚îú‚îÄ‚îÄ overview.md          ‚Üê Vue d'ensemble de l'application
‚îÇ   ‚îú‚îÄ‚îÄ architecture.md      ‚Üê Architecture d√©taill√©e
‚îÇ   ‚îú‚îÄ‚îÄ getting_started.md   ‚Üê Guide de d√©marrage pour les IA
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ MACHINES/
‚îÇ   ‚îú‚îÄ‚îÄ _README.md           ‚Üê Comment documenter une machine
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ CODING/
    ‚îú‚îÄ‚îÄ normes_code.md       ‚Üê Normes de code
    ‚îú‚îÄ‚îÄ testing_guide.md     ‚Üê Guide de tests
    ‚îî‚îÄ‚îÄ ...
```

#### 2. **Sch√©mas JSON comme contrat**

Les sch√©mas JSON sont le **contrat** entre les IA et l'application. Toute action doit √™tre valid√©e contre un sch√©ma.

**Exemple de validation** :
```python
import jsonschema
import json

def validate_action(action):
    """Valide une action JSON contre son sch√©ma."""
    schema_name = action.get("schema")
    
    with open(f"SCHEMAS/actions/{schema_name}.schema.json", "r") as f:
        schema = json.load(f)
    
    try:
        jsonschema.validate(instance=action, schema=schema)
        return True, None
    except jsonschema.ValidationError as e:
        return False, str(e)

# Utilisation
action = {
    "schema": "CreatePattern.v1",
    "machineId": "behringer.rd9",
    "steps": [...]
}

valid, error = validate_action(action)
if not valid:
    print(f"‚ùå Action invalide : {error}")
else:
    print("‚úÖ Action valide")
```

#### 3. **ADR (Architecture Decision Records) comme m√©moire collective**

Chaque d√©cision architecturale importante est document√©e dans un ADR. Les IA futures peuvent consulter ces ADR pour comprendre **pourquoi** une d√©cision a √©t√© prise.

**Format ADR** :
```markdown
# ADR-20251021-dsp-oversampling

## Contexte

Les oscillateurs na√Øfs (sawtooth, square) produisent de l'aliasing audible aux hautes fr√©quences.

## Options

1. **Pas d'oversampling** : Simple mais aliasing audible
2. **Oversampling √ó2** : R√©duit l'aliasing, CPU mod√©r√©
3. **Oversampling √ó4** : Aliasing minimal, CPU √©lev√©

## D√©cision

**Oversampling √ó2 s√©lectif** : uniquement pour les non-lin√©arit√©s (distorsion, saturation).

## Cons√©quences

- ‚úÖ Aliasing r√©duit de ~60%
- ‚úÖ CPU acceptable (< 30% sur iPhone 14 Pro Max)
- ‚ùå Complexit√© accrue (upsampling + downsampling)

## Alternatives rejet√©es

- **Oversampling √ó4** : CPU > 50%, inacceptable sur mobile
- **PolyBLEP sans oversampling** : Aliasing r√©siduel sur les filtres r√©sonants
```

#### 4. **Logs SQLite comme journal de bord**

Toutes les actions importantes (builds, tests, exports MIDI) sont logg√©es dans une base SQLite. Les IA peuvent consulter ces logs pour d√©tecter les patterns d'erreurs.

**Sch√©ma SQLite** :
```sql
CREATE TABLE logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT NOT NULL,
    level TEXT NOT NULL,  -- INFO, WARN, ERROR
    component TEXT NOT NULL,  -- UI, DSP, MIDI, GPT
    message TEXT NOT NULL,
    context TEXT  -- JSON avec d√©tails
);

CREATE INDEX idx_logs_timestamp ON logs(timestamp);
CREATE INDEX idx_logs_level ON logs(level);
CREATE INDEX idx_logs_component ON logs(component);
```

**Exemple de requ√™te** :
```sql
-- D√©tecter les erreurs r√©currentes
SELECT component, message, COUNT(*) as count
FROM logs
WHERE level = 'ERROR'
  AND timestamp > datetime('now', '-7 days')
GROUP BY component, message
ORDER BY count DESC
LIMIT 10;
```

#### 5. **Tests et goldens comme garde-fous**

Les tests et les goldens sont les **garde-fous** qui emp√™chent les r√©gressions. Toute modification qui casse un golden doit √™tre justifi√©e musicalement.

**Workflow de modification d'un golden** :
```
1. Modifier le code
2. Ex√©cuter les tests
3. Si un golden √©choue :
   a. Analyser la diff√©rence (diff MIDI, diff audio)
   b. Justifier musicalement la modification
   c. Mettre √† jour le golden
   d. Documenter dans la PR
4. Valider avec un humain
```

---

## üéº Symbiose IA Compositrice ‚Üî App : L'IA comme membre natif

### Principe fondamental

L'IA compositrice n'est **pas** un outil externe. Elle est un **membre natif** de l'application qui :

1. **Lit** l'√©tat complet du projet (ProjectState.v1)
2. **Comprend** les capacit√©s disponibles (Capabilities.v1)
3. **Respecte** les contraintes de l'utilisateur (UserIntent.v1)
4. **Propose** des actions JSON valid√©es (AddMachine.v1, CreatePattern.v1, etc.)
5. **Apprend** de ses erreurs via l'historique des actions

### Architecture de la symbiose

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Utilisateur                                                 ‚îÇ
‚îÇ  ‚îú‚îÄ "Cr√©e un groove funky avec le RD-9"                     ‚îÇ
‚îÇ  ‚îî‚îÄ Validation manuelle des actions propos√©es               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  IA Compositrice (GPT-4.1-mini)                              ‚îÇ
‚îÇ  ‚îú‚îÄ Lit ProjectState.v1 (machines, patterns, tempo)         ‚îÇ
‚îÇ  ‚îú‚îÄ Lit Capabilities.v1 (s√©quenceurs, r√©solutions)          ‚îÇ
‚îÇ  ‚îú‚îÄ Lit Inventory.v1 (machines poss√©d√©es)                   ‚îÇ
‚îÇ  ‚îú‚îÄ Lit UserIntent.v1 (style, contraintes, dur√©e)           ‚îÇ
‚îÇ  ‚îî‚îÄ G√©n√®re ActionBatch.v1 (liste d'actions atomiques)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Validateur JSON (jsonschema)                                ‚îÇ
‚îÇ  ‚îú‚îÄ Valide chaque action contre son sch√©ma                  ‚îÇ
‚îÇ  ‚îú‚îÄ Rejette les actions invalides                           ‚îÇ
‚îÇ  ‚îî‚îÄ Retourne Acknowledgement.v1 (succ√®s/√©chec)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Application (JavaScript)                                    ‚îÇ
‚îÇ  ‚îú‚îÄ Applique les actions valid√©es                           ‚îÇ
‚îÇ  ‚îú‚îÄ Met √† jour ProjectState.v1                              ‚îÇ
‚îÇ  ‚îú‚îÄ D√©clenche le DSP (pr√©-√©coute)                           ‚îÇ
‚îÇ  ‚îî‚îÄ Logue dans SQLite (historique)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Protocole de communication IA ‚Üî App

#### 1. **Entr√©es (App ‚Üí IA)**

**ProjectState.v1** : √âtat complet du projet
```json
{
  "schema": "ProjectState.v1",
  "machines": [
    {"id": "behringer.rd9", "channel": 10, "position": {"x": 100, "y": 100}}
  ],
  "patterns": [
    {"id": "kick_pattern", "machineId": "behringer.rd9", "steps": [...]}
  ],
  "tempo": 128,
  "signature": "4/4"
}
```

**Capabilities.v1** : Capacit√©s disponibles
```json
{
  "schema": "Capabilities.v1",
  "sequencers": {
    "supportedLengths": [12, 16, 32, 48, 64, 68, 128, 256],
    "resolutionPPQ": [96, 192, 480],
    "features": ["microTiming", "ratchet", "probability", "slide"]
  },
  "dsp": {
    "maxMachines": 4,
    "maxCPU": 0.3
  }
}
```

**Inventory.v1** : Machines poss√©d√©es par l'utilisateur
```json
{
  "schema": "Inventory.v1",
  "machines": [
    {"id": "behringer.rd9", "owned": true},
    {"id": "behringer.td3", "owned": true},
    {"id": "moog.subsequent37", "owned": false}
  ]
}
```

**UserIntent.v1** : Intention artistique
```json
{
  "schema": "UserIntent.v1",
  "style": "funky groove",
  "constraints": {
    "bpm": 128,
    "duration": "4 bars",
    "machines": ["behringer.rd9"]
  },
  "references": [
    "Daft Punk - Around the World",
    "Justice - D.A.N.C.E."
  ]
}
```

#### 2. **Sorties (IA ‚Üí App)**

**ActionBatch.v1** : Liste d'actions atomiques
```json
{
  "schema": "ActionBatch.v1",
  "actions": [
    {
      "schema": "CreatePattern.v1",
      "machineId": "behringer.rd9",
      "lengthSteps": 16,
      "steps": [
        {"t": 0, "note": 36, "vel": 110},
        {"t": 4, "note": 38, "vel": 90},
        {"t": 8, "note": 36, "vel": 110},
        {"t": 12, "note": 38, "vel": 90}
      ],
      "automation": [
        {"target": "accent", "at": 0, "val": 0.7}
      ],
      "explain": "Kick 4/4 avec snare sur 2 et 4"
    },
    {
      "schema": "SetParam.v1",
      "machineId": "behringer.rd9",
      "param": "swing",
      "value": 0.55,
      "explain": "Swing l√©ger pour groove funky"
    }
  ]
}
```

#### 3. **Validation et feedback**

**Acknowledgement.v1** : Confirmation d'ex√©cution
```json
{
  "schema": "Acknowledgement.v1",
  "success": true,
  "actionsExecuted": 2,
  "errors": [],
  "warnings": [
    "Swing > 0.5 peut affecter le timing MIDI"
  ],
  "timestamp": "2025-10-21T14:30:00Z"
}
```

### Apprentissage de l'IA via l'historique

L'IA compositrice **apprend** de ses erreurs en consultant l'historique des actions dans la base SQLite.

**Exemple de requ√™te** :
```sql
-- Actions qui ont √©chou√© r√©cemment
SELECT action_type, error_message, COUNT(*) as count
FROM action_history
WHERE success = 0
  AND timestamp > datetime('now', '-7 days')
GROUP BY action_type, error_message
ORDER BY count DESC;
```

**Exemple d'apprentissage** :
```
Erreur r√©currente d√©tect√©e :
- Action : CreatePattern.v1
- Erreur : "Pattern length 24 not supported"
- Fr√©quence : 5 fois en 7 jours

Correction automatique :
- Utiliser uniquement les longueurs support√©es : [12, 16, 32, 48, 64, 68, 128, 256]
- Ajouter une validation pr√©alable avant de g√©n√©rer l'action
```

---

## üìã Checklist m√©ta-r√©flexive (√† suivre pour chaque contribution)

### Avant de commencer

- [ ] J'ai lu int√©gralement AGENTS.md, README.md, et DOCUMENTATION/
- [ ] J'ai calcul√© les hash SHA-256 des fichiers lus
- [ ] J'ai post√© un Acknowledgement.v1 avec les hash
- [ ] J'ai compris l'intention r√©elle derri√®re cette t√¢che
- [ ] J'ai identifi√© les invariants √† pr√©server
- [ ] J'ai r√©fl√©chi aux cons√©quences √† long terme

### Pendant le d√©veloppement

- [ ] Mon code est coh√©rent avec l'architecture existante
- [ ] J'ai √©vit√© les patterns de d√©g√©n√©rescence (duplication, couplage fort, etc.)
- [ ] J'ai √©crit des tests avant de refactoriser
- [ ] J'ai mesur√© les performances (CPU, latence, m√©moire)
- [ ] J'ai document√© les d√©cisions non √©videntes

### Apr√®s le d√©veloppement

- [ ] J'ai relu mon code comme si c'√©tait celui d'un autre
- [ ] J'ai identifi√© et corrig√© les faiblesses
- [ ] J'ai g√©n√©r√© la documentation automatiquement
- [ ] J'ai valid√© contre les sch√©mas JSON
- [ ] J'ai ex√©cut√© tous les tests (unitaires, int√©gration, goldens)
- [ ] J'ai v√©rifi√© que les m√©triques de sant√© sont dans les cibles

### Avant de soumettre la PR

- [ ] J'ai rempli le template de PR compl√®tement
- [ ] J'ai inclus un Acknowledgement.v1 √† jour
- [ ] J'ai document√© les changements dans CHANGELOG.md (si applicable)
- [ ] J'ai mis √† jour les ADR si n√©cessaire
- [ ] J'ai v√©rifi√© qu'aucune cl√© API n'est expos√©e

---

## üöÄ Conclusion : Vers une IA d√©veloppeuse autonome et responsable

Ce document enrichi transforme les IA d√©veloppeuses en **architectes r√©flexives** capables de :

1. **Penser avant d'agir** : M√©ta-r√©flexivit√© syst√©matique
2. **Pr√©venir la dette technique** : D√©tection des patterns de d√©g√©n√©rescence
3. **Collaborer avec le d√©p√¥t** : Symbiose IA ‚Üî d√©p√¥t via documentation, sch√©mas, ADR, logs
4. **Apprendre de ses erreurs** : Historique SQLite et analyse des √©checs
5. **Produire du code p√©renne** : Tests, goldens, documentation auto-g√©n√©r√©e

**Le d√©p√¥t n'est plus un simple stockage de code, c'est un organisme vivant qui guide, valide, et fait √©voluer les IA vers l'excellence.**

---

**Fait avec üß† et ü§ñ pour un avenir o√π humains et IA cr√©ent ensemble**

